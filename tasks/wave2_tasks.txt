1)Никита работает на автостоянке. В его обязанности входит запись номеров въезжающих машин. Это довольно скучное занятие и поэтому Никита решил оптимизировать этот процесс. Он хочет, чтобы компьютер обрабатывал изображение с камеры перед въездом в автостоянку и записывал номера. Никита уже написал софт, который обнаруживает на изображении последовательности из шести символов; осталось только проверять, является ли данная последовательность номером. Но из-за того, что Никита постоянно отвлекается на запись номеров, он просит вас о помощи.
 
Автомобильный номер – строка из шести символов. Первый символ – заглавная латинская буква, далее следует 3 цифры, и после – две заглавные латинские буквы. Например, строка "P142EQ" является номером. Вам будет дана строка, состоящая из шести символов, необходимо ответить, является ли строка автомобильным номером.
 
Формат входных данных:
В единственной строке находится строка из шести символов, состоящая из цифр и заглавных латинских букв.
 
Формат выходных данных:
Если строка является автомобильным номером, то необходимо вывести "Yes", в ином случае – "No" без кавычек.
 
Sample Input 1:
K040LE
Sample Output 1:
Yes
Sample Input 2:
M3239L
Sample Output 2:
No
 
2)Студент Денис часто прогуливает свои пары в университете. Сегодня, когда Денис пришел в деканат, он узнал, что нужно за каждую пропущенную пару написать объяснительную.
 
Денису выдали один бланк для написания объяснительной. Ему нужно сделать еще nn копий данного бланка. Для этого в его распоряжении есть два ксерокса. Первый ксерокс тратит на копирование одного листа одну секунду, а второй – две секунды. Копию можно делать как с оригинала, так и с копии. Денис может использовать оба ксерокса одновременно. Определите, какое минимальное время необходимо Денису для получения nn копий объяснительной.
 
Формат входных данных:
В единственной строке дано число nn – необходимое число копий (1≤n≤10001≤n≤1000).
 
Формат выходных данных:
Выведите одно число – минимальное время в секундах, необходимое для получения nn копий.
 
Sample Input 1:
2
Sample Output 1:
2
Sample Input 2:
5
 
3)Сегодня Ринат на уроке узнал про новую битовую операцию – XOR двух чисел. Напомним, что XOR или Исключающим ИЛИ, называется бинарная операция, которая применяется к каждой паре битов, стоящих на одинаковых позициях в двоичных представлениях чисел так, что, если биты равны, то в результате на этой позиции стоит 0, если же биты различны, то 1. Например, 3 XOR 5 = 6, потому что 310310 = 01120112, 510510 = 10121012, поэтому после применения операции второй и третий бит становятся равными 1, а первый бит – 0, таким образом получается 11021102 = 610610.
 
Учитель дал Ринату массив различных чисел и попросил написать массив, в котором все числа различны и нет ни одного числа из массива, который дал учитель. При этом, чтобы XOR всех чисел в массиве Рината был равен XOR всех чисел в массиве учителя.
 
Формат входных данных:
В первой строке дано число 11.
 
Во второй сроке дано число aa (1≤a≤28−11≤a≤28−1).
 
Формат выходных данных:
Выведите элемента вашего массива, чтобы все числа в вашем массиве и массиве учителя отличались.
 
Все числа вашего массива bibi должны находиться в промежутке (0≤bi≤2300≤bi≤230).
 
Количество элементов не должно превосходить 105105.
 
Sample Input:
1
27
Sample Output:
21 14
 
4)Данная задача является продолжением предыдущей, но только на проверку более общего решения.
 
Сегодня Ринат на уроке узнал про новую битовую операцию – XOR двух чисел. Напомним, что XOR или Исключающим ИЛИ, называется бинарная операция, которая применяется к каждой паре битов, стоящих на одинаковых позициях в двоичных представлениях чисел так, что, если биты равны, то в результате на этой позиции стоит 0, если же биты различны, то 1. Например, 3 XOR 5 = 6, потому что 310310 = 01120112, 510510 = 10121012, поэтому после применения операции второй и третий бит становятся равными 1, а первый бит – 0, таким образом получается 11021102 = 610610.
 
Учитель дал Ринату массив различных чисел и попросил написать массив, в котором все числа различны и нет ни одного числа из массива, который дал учитель. При этом, чтобы XOR всех чисел в массиве Рината был равен XOR всех чисел в массиве учителя.
 
Формат входных данных:
В первой строке дано число nn – количество элементов в массиве учителя (1≤n≤21≤n≤2).
 
Во второй сроке дано nn чисел aiai – элементы массива (0≤ai≤2300≤ai≤230).
 
Гарантируется, что XOR всех aiai не равен 0.
 
Формат выходных данных:
Выведите элемента вашего массива, чтобы все числа в вашем массиве и массиве учителя отличались.
 
Все числа вашего массива bibi должны находиться в промежутке (0≤bi≤2300≤bi≤230).
 
Количество элементов не должно превосходить 105105.
 
Sample Input 1:
1
27
Sample Output 1:
21 14
Sample Input 2:
2
5 6
Sample Output 2:
7 4
 
5)Данная задача является продолжением предыдущей, но только на проверку более общего решения.
 
Сегодня Ринат на уроке узнал про новую битовую операцию – XOR двух чисел. Напомним, что XOR или Исключающим ИЛИ, называется бинарная операция, которая применяется к каждой паре битов, стоящих на одинаковых позициях в двоичных представлениях чисел так, что, если биты равны, то в результате на этой позиции стоит 0, если же биты различны, то 1. Например, 3 XOR 5 = 6, потому что 310310 = 01120112, 510510 = 10121012, поэтому после применения операции второй и третий бит становятся равными 1, а первый бит – 0, таким образом получается 11021102 = 610610.
 
Учитель дал Ринату массив различных чисел и попросил написать массив, в котором все числа различны и нет ни одного числа из массива, который дал учитель. При этом, чтобы XOR всех чисел в массиве Рината был равен XOR всех чисел в массиве учителя.
 
Формат входных данных:
В первой строке дано число nn – количество элементов в массиве учителя (1≤n≤1051≤n≤105).
 
Во второй сроке дано nn чисел aiai – элементы массива (0≤ai≤2300≤ai≤230).
 
Гарантируется, что XOR всех aiai не равен 0.
 
Формат выходных данных:
Выведите элемента вашего массива, чтобы все числа в вашем массиве и массиве учителя отличались.
 
Все числа вашего массива bibi должны находиться в промежутке (0≤bi≤2300≤bi≤230).
 
Количество элементов не должно превосходить 105105.
 
Sample Input 1:
1
27
Sample Output 1:
21 14
Sample Input 2:
2
5 6
Sample Output 2:
7 4
Sample Input 3:
3
1 2 4
Sample Output 3:
5 3 9 8
Sample Input 4:
3
3 5 1
Sample Output 4:
10 9 6 2
 
 
6)Азат уже очень давно отдыхает на островах. Сегодня он решил, что хочет перебраться на другой остров. Все острова пронумерованы целыми числами. Какие-то из островов соединены мостами. Но вот незадача, какие-то из островов ушли под воду и попасть на них никак нельзя. Азат сейчас находится на острове с номером vv и хочет попасть на остров с номером uu. Ваша задача проверить, сможет ли он это сделать.
 
Формат входных данных:
В первой строке содержится 4 числа: nn, mm, vv, и uu (1≤n≤5,0≤m≤5,1≤v,u≤n1≤n≤5,0≤m≤5,1≤v,u≤n). Количество островов, количество мостов, номер острова, на котором находится Азат, и номер острова, на который он хочет попасть.
 
Следующие mm строк описывают мосты. Каждая строка содержит 2 числа: aa, bb (1≤a,b≤n1≤a,b≤n). Мост между островами с номерами aa и bb соответственно. По мосту можно попасть с острова aa на bb, так и с острова bb на aa.
 
Следующая строка содержит одно число kk (0≤k≤n0≤k≤n). Количество островов, которые затонули.
 
Следующая строка содержит kk чисел cici (1≤ci≤n1≤ci≤n) – номера затонувших островов. Гарантируется, что острова uu и vv не затоплены. Если kk равно 00, то данная строка отсутствует.
 
Формат выходных данных:
Выведите слово "YES" без кавычек, если можно добраться от острова vv до острова uu, не посещая затопленные острова, "NO" иначе.
 
Sample Input 1:
4 4 1 4
1 2
2 3
3 4
1 3
1
2
Sample Output 1:
YES
Sample Input 2:
5 5 1 5
1 2
2 3
3 4
4 5
1 3
2 4
2
2 3
Sample Output 2:
NO
 
7)Данная задача является продолжением предыдущей, но только на проверку более общего решения.
 
Азат уже очень давно отдыхает на островах. Сегодня он решил, что хочет перебраться на другой остров. Все острова пронумерованы целыми числами. Какие-то из островов соединены мостами. Но вот незадача, какие-то из островов ушли под воду и попасть на них никак нельзя. Азат сейчас находится на острове с номером vv и хочет попасть на остров с номером uu. Ваша задача проверить, сможет ли он это сделать.
 
Формат входных данных:
В первой строке содержится 4 числа: nn, mm, vv, и uu (1≤n≤1000,0≤m≤5000,1≤v,u≤n1≤n≤1000,0≤m≤5000,1≤v,u≤n). Количество островов, количество мостов, номер острова, на котором находится Азат, и номер острова, на который он хочет попасть.
 
Следующие mm строк описывают мосты. Каждая строка содержит 2 числа: aa, bb (1≤a,b≤n1≤a,b≤n). Мост между островами с номерами aa и bb соответственно. По мосту можно попасть с острова aa на bb, так и с острова bb на aa.
 
Следующая строка содержит одно число kk (0≤k≤n0≤k≤n). Количество островов, которые затонули.
 
Следующая строка содержит kk чисел cici (1≤ci≤n1≤ci≤n) – номера затонувших островов. Гарантируется, что острова uu и vv не затоплены. Если kk равно 00, то данная строка отсутствует.
 
Формат выходных данных:
Выведите слово "YES" без кавычек, если можно добраться от острова vv до острова uu, не посещая затопленные острова, "NO" иначе.
 
Sample Input 1:
4 4 1 4
1 2
2 3
3 4
1 3
1
2
Sample Output 1:
YES
Sample Input 2:
5 6 1 5
1 2
2 3
3 4
4 5
1 3
2 4
2
2 3
Sample Output 2:
NO
 
 
8)На прямой отмечено nn точек. Нужно соединить некоторые точки отрезками одинаковой длины, чтобы можно было по отрезкам дойти от первой точки до последней, причём можно использовать не более kk отрезков. Среди всех таких длин отрезков требуется вывести минимальную.
 
Формат входных данных:
В первой строке заданы целые числа nn и kk (2≤n≤25002≤n≤2500, 1≤k≤n−11≤k≤n−1).
 
На следующей строке в возрастающем порядке заданы nn различных неотрицательных целых чисел, каждое из которых не превосходит 100000100000.
 
Формат выходных данных:
Выведите одно целое число – ответ на задачу.
 
Sample Input 1:
5 3
1 2 3 4 5
Sample Output 1:
2
Sample Input 2:
9 3
1 3 4 5 7 8 9 10 13
Sample Output 2:
4